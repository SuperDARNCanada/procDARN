use assert_unordered::assert_eq_unordered;
use backscatter_rs::fitting::fitacf3::fitacf_v3::fit_rawacf_record;
use backscatter_rs::utils::hdw::HdwInfo;
use chrono::NaiveDate;
use dmap::types::{DmapField, DmapVec};
use ndarray::Array;
use std::iter::zip;

#[test]
fn test_fitacf3() {
    // Create fitacf file from rawacf file
    let rawacf = dmap::read_rawacf("tests/test_files/test.rawacf".to_string().into()).expect("Could not read records");
    let mut fitacf_records = vec![];

    let rec = &rawacf[0];
    let file_datetime = NaiveDate::from_ymd_opt(
        rec.get(&"time.yr".to_string())
            .unwrap()
            .clone()
            .try_into()
            .expect("Unable to get time.yr"),
        rec.get(&"time.mo".to_string())
            .unwrap()
            .clone()
            .try_into()
            .expect("Unable to get time.mo"),
        rec.get(&"time.dy".to_string())
            .unwrap()
            .clone()
            .try_into()
            .expect("Unable to get time.dy"),
    )
    .unwrap()
    .and_hms_opt(
        rec.get(&"time.hr".to_string())
            .unwrap()
            .clone()
            .try_into()
            .expect("Unable to get time.hr"),
        rec.get(&"time.mt".to_string())
            .unwrap()
            .clone()
            .try_into()
            .expect("Unable to get time.mt"),
        rec.get(&"time.sc".to_string())
            .unwrap()
            .clone()
            .try_into()
            .expect("Unable to get time.sc"),
    )
    .unwrap();
    let hdw = HdwInfo::new(
        rec.get(&"stid".to_string())
            .unwrap()
            .clone()
            .try_into()
            .expect("Unable to get stid"),
        file_datetime,
    )
    .expect("Unable to get hdw info");

    for rec in rawacf {
        fitacf_records.push(fit_rawacf_record(&rec, &hdw).expect("Could not fit record"));
    }

    // Compare to fitacf file generated by RST
    let rst = dmap::read_fitacf("tests/test_files/test.fitacf".to_string().into()).expect("Could not read test.fitacf records");
    let soft_fields = vec!["origin.time", "origin.command"];
    for (read_rec, rst_rec) in zip(fitacf_records.iter(), rst.iter()) {
        assert_eq_unordered!(read_rec.keys(), rst_rec.keys());
        for k in read_rec.keys() {
            if soft_fields.contains(&&**k) {
            } else {
                match read_rec.get(k) {
                    Some(DmapField::Vector(DmapVec::Float(x))) => {
                        assert!(rst_rec.get(k).is_some(), "Testing {k}");
                        if let Some(DmapField::Vector(DmapVec::Float(y))) = rst_rec.get(k) {
                            assert!(
                                Array::<f32, _>::zeros(x.raw_dim())
                                    .abs_diff_eq(&((x - y) / x), 1e-5),
                                "Testing {}\nleft: {:?}\nright: {:?}",
                                k,
                                x,
                                y
                            )
                        }
                    }
                    Some(_) => {
                        assert_eq!(read_rec.get(k), rst_rec.get(k), "Testing {}", k)
                    }
                    None => {}
                }
            }
        }
    }
}
